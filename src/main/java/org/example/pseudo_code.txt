run:
  parameters:
    graph
  steps:
    initialize: list of Island instances with graph
    loop: for each generation
      steps:
        loop: for each island in islands
          steps:
            call: evolve()
        condition: if generation % MIGRATION_INTERVAL == 0
          steps:
            call: migrate(islands)
    return: best path among all islands

evolve:
  steps:
    call: evaluatePopulation()  # оцінка пристосованості
    initialize: nextGeneration = []
    loop: for each individual in population
      steps:
        assign: parent1 = tournamentSelection()
        assign: parent2 = tournamentSelection()
        assign: child = crossover(parent1, parent2)
        call: mutate(child)
        condition: if isValidPath(child)
          steps:
            add: child to nextGeneration
        else:
            add: parent1 to nextGeneration
    replace: population = nextGeneration

migrate:
  parameters:
    islands
  steps:
    loop: for each island i in islands
      steps:
        assign: source = island[i]
        assign: target = island[(i + 1) % total_islands]
        assign: migrants = source.getBestIndividuals(MIGRATION_COUNT)
        call: target.addMigrants(migrants)

evaluatePopulation:
  steps:
    loop: for each individual in population
      steps:
        call: calculateFitness(individual)

calculateFitness:
  parameters:
    path, graph
  steps:
    initialize: fitness = 0
    loop: for i = 0 to path.length - 2
      steps:
        increment: fitness += graph[path[i]][path[i+1]]
    return: fitness


Початок
 └──> Створення NUM_ISLANDS островів
         └──> Кожен острів паралельно ініціалізує популяцію
         └──> Для кожного покоління:
               └──> Паралельна еволюція кожного острова
                    └──> Всередині острова: паралельний відбір, кросовер, мутація
               └──> Якщо потрібна міграція:
                    ├──> Збір мігрантів паралельно
                    └──> Вставка мігрантів послідовно
 └──> Вибір найкращого шляху серед островів паралельно
Кінець

Start

// Initialize islands
For each island:
    Initialize population (generate random individuals in parallel)

// Main evolutionary loop
For each generation:
    For each island:
        - Evaluate fitness for each individual (in parallel)
        - For each individual in the new generation (in parallel):
            - Select parents using tournament selection
            - Apply crossover
            - Apply mutation
            - If child is valid, add it to the new generation else copy a parent
        - Replace the old population with the new generation

    If (generation number % migration interval == 0):
        For each island:
            - Select best individuals as migrants
            - Send migrants to the next island

// After evolution
For each island:
    - Get the best individual (path)

Select the best path among all islands

End

Start

// Initialization
for each island:
    parallel initializePopulation()

// Evolution loop
for gen = 1 to MAX_GENERATIONS:
    for each island:
        parallel evaluateFitness()
        parallel evolution:
            for i = 1 to POPULATION_SIZE:
                p1 ← tournamentSelection()
                p2 ← tournamentSelection()
                child ← crossover(p1, p2)
                mutate(child)
                if isValid(child):
                    nextGen[i] ← child
                else:
                    nextGen[i] ← copy(p1)
        population ← nextGen

    if gen mod MIGRATION_INTERVAL == 0:
        for each island:
            migrants ← selectBest(MIGRATION_COUNT)
            sendToNextIsland(migrants)

// Final selection
for each island:
    best ← getBestIndividual()

return min(best from all islands)

End
